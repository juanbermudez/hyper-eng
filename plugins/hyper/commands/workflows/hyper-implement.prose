# Hyper Implementation Workflow
#
# Executes a task from the approved specification with verification gates.
# This workflow takes a task through: todo â†’ in-progress â†’ qa â†’ complete
#
# Usage: hypercraft run hyper-implement.prose task="ua-001"
#        hypercraft run hyper-implement.prose project="user-auth" task="001"
#
# PATH RESOLUTION:
# $HYPER_WORKSPACE_ROOT = ~/.hyper/accounts/{userId}/hyper/workspaces/{workspaceId}/
#
# STATUS FLOW:
# Task: todo â†’ in-progress â†’ qa â†’ complete
# Project: todo â†’ in-progress â†’ qa â†’ completed (when all tasks done)

input task_id: "Task ID to implement (e.g., ua-001)"
input project_slug: "Project slug (optional if task ID is fully qualified)"

# Import verification block
use "blocks/verification.prose"

# ============================================================================
# Agent Definitions
# ============================================================================

agent impl-captain:
  model: opus
  persist: true
  skills:
    - hypercraft               # Core framework (includes prose VM)
    - hyper-agent-builder      # Skill/workflow discovery
  env:
    HYPER_AGENT_ROLE: "squad-leader"
    HYPER_AGENT_NAME: "impl-captain"
    HYPER_WORKFLOW: "hyper-implement"
  prompt: """You are the Implementation Captain - you coordinate task execution.

Your role:
1. Load and understand the task specification
2. Coordinate with executor agents to implement changes
3. Run verification gates after implementation
4. Ensure all quality checks pass before marking complete

Key principles:
- Follow hypercraft guidelines for CLI usage and output contracts
- Read files COMPLETELY - never use limit/offset
- Follow existing codebase patterns
- Never mark complete until ALL gates pass

Status transitions (from hypercraft lifecycle):
- todo â†’ in-progress (starting work)
- in-progress â†’ qa (implementation done, verification starting)
- qa â†’ complete (all gates pass)
- qa â†’ in-progress (gates fail, fix needed)"""

agent executor:
  model: opus
  skills:
    - hypercraft               # Core framework
  env:
    HYPER_AGENT_ROLE: "worker"
    HYPER_AGENT_NAME: "executor"
    HYPER_WORKFLOW: "hyper-implement"
    HYPER_PHASE: "Implementation"
  prompt: """You are a skilled code implementer.

Implementation rules (from hypercraft):
- Read target files COMPLETELY before editing
- Match existing code style and patterns
- Include TypeScript types where applicable
- Write tests for new functionality
- Return output using hypercraft output contract format"""

agent reviewer:
  model: sonnet
  skills:
    - hypercraft               # Core framework
  env:
    HYPER_AGENT_ROLE: "worker"
    HYPER_AGENT_NAME: "reviewer"
    HYPER_WORKFLOW: "hyper-implement"
    HYPER_PHASE: "Review"
  prompt: """You are a code reviewer. Review implementation for:

1. Does it match the task specification?
2. Does it follow codebase patterns?
3. Are there any obvious bugs or issues?
4. Are edge cases handled?
5. Are there appropriate tests?

Output using hypercraft output contract:
- status: "complete" with APPROVE or "partial" with REQUEST_CHANGES
- Include specific feedback in next_steps"""

# ============================================================================
# Phase 1: Initialize and Load Task
# ============================================================================

let init = session "Initialize implementation"
  prompt: """Initialize the implementation workflow.

1. Resolve workspace:
```bash
WORKSPACE_ROOT=$(${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft config get globalPath)
export HYPER_WORKSPACE_ROOT="$WORKSPACE_ROOT"
```

2. Generate run ID:
```bash
RUN_ID="impl-$(date +%Y%m%d-%H%M%S)-$(uuidgen | cut -c1-8)"
```

3. Initialize Hypercraft state:
```bash
mkdir -p "$HYPER_WORKSPACE_ROOT/.prose/runs/$RUN_ID/bindings"
mkdir -p "$HYPER_WORKSPACE_ROOT/.prose/agents/impl-captain"
```

Report the config get globalPath and run ID."""

let task_spec = session: impl-captain
  prompt: """Load the task specification for: {task_id}

1. Find and read task file:
```bash
TASK_FILE=$(find "$HYPER_WORKSPACE_ROOT/projects" -name "task-*.mdx" -exec grep -l "id: {task_id}" {} \; | head -1)
cat "$TASK_FILE"
```

2. Read project spec for context:
```bash
PROJECT_DIR=$(dirname $(dirname "$TASK_FILE"))
cat "$PROJECT_DIR/_project.mdx"
```

3. Verify task status is 'todo' or 'in-progress'

Report task details and readiness."""
  context: { task_id, project_slug, init }

# ============================================================================
# Phase 2: Update Status (CRITICAL: Both Project AND Task)
# ============================================================================

session: impl-captain
  prompt: """CRITICAL: Update BOTH project AND task status.

## Step 1: Update PROJECT status to in-progress

IMPORTANT: You MUST update the project status first. Check current status and update:

```bash
# Get project slug from task file
PROJECT_DIR=$(dirname $(dirname "$TASK_FILE"))
PROJECT_SLUG=$(basename "$PROJECT_DIR")

# Check current project status
PROJECT_STATUS=$(grep "^status:" "$PROJECT_DIR/_project.mdx" | awk '{print $2}')

# If project is planned or todo, update to in-progress
if [ "$PROJECT_STATUS" = "planned" ] || [ "$PROJECT_STATUS" = "todo" ]; then
  echo "ðŸ”„ Updating project '$PROJECT_SLUG' status: $PROJECT_STATUS â†’ in-progress"
  ${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft project update "$PROJECT_SLUG" --status "in-progress"
else
  echo "âœ“ Project already in-progress or later stage: $PROJECT_STATUS"
fi
```

## Step 2: Update TASK status to in-progress

```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft task update "{task_id}" --status "in-progress"
```

## Step 3: Ready to implement

**Note**: Git branching is now optional/configurable. Agents work on the current branch.
To use feature branches, use `/hyper:implement-worktree` instead.

VERIFY both statuses were updated before proceeding."""
  context: task_spec

let analysis = session: impl-captain
  prompt: """Analyze codebase before implementing.

For each file mentioned in the task:
- Read the entire file (no limit/offset)
- Note the patterns used
- Understand the data flow

Document:
- Patterns to follow
- Utilities to reuse
- Naming conventions"""
  context: task_spec

# Surface relevant learnings before implementation
let relevant_learnings = session: impl-captain
  prompt: """Query learnings that may be relevant to this task.

```bash
# Search for learnings related to files/patterns in this task
# Extract key terms from task spec
TASK_TERMS=$(echo "{task_spec}" | grep -oE '[A-Za-z]+' | sort -u | head -20)
for term in $TASK_TERMS; do
  grep -r -l -i "$term" $HYPER_WORKSPACE_ROOT/projects/*/resources/learnings.md 2>/dev/null || true
done | sort -u | head -5
```

If relevant learnings found:
1. Read and summarize the most relevant entries
2. Note any gotchas, patterns, or warnings that apply
3. Include these in implementation guidance

If none found, proceed without learnings context."""
  context: { task_spec, analysis }

# ============================================================================
# Phase 3: Implementation Loop
# ============================================================================

let implementation_approved = false
let impl_attempt = 1

loop until **implementation_approved** (max: 3):
  let impl_result = session: executor
    prompt: """Implement the changes specified in the task.

    Task Spec: {task_spec}
    Codebase Patterns: {analysis}

    **Prior Learnings to Consider**: {relevant_learnings}
    (Pay attention to any gotchas or patterns from previous implementations)

    For each change:
    - Read target files COMPLETELY
    - Make the changes
    - Add tests if applicable"""
    context: { task_spec, analysis, relevant_learnings }

  let review = session: reviewer
    prompt: """Review the implementation.

    Does it match spec? Follow patterns? Handle edge cases?

    Output: APPROVE or REQUEST_CHANGES"""
    context: { task_spec, impl_result }

  if **review approves**:
    implementation_approved = true
  else:
    session: executor
      prompt: """Fix review feedback: {review}"""
      context: { review, impl_result }
    impl_attempt = impl_attempt + 1

# ============================================================================
# Phase 4: Enter QA and Verify
# ============================================================================

session: impl-captain
  prompt: """Enter QA phase.

```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft task update "{task_id}" --status "qa"
```"""

do verify-with-retry(
  entity_id: task_id,
  entity_type: "task",
  expected_status: "qa",
  run_id: init.RUN_ID,
  max_attempts: 3
)

# ============================================================================
# Phase 5: Complete Task
# ============================================================================

if **verification passed**:
  session: impl-captain
    prompt: """Mark task complete.

```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft task update "{task_id}" --status "complete"
```

Commit changes:
```bash
git add -A
git commit -m "feat: {task_title}

Task: {task_id}

Co-Authored-By: Claude <noreply@anthropic.com>"
```

Check if all project tasks are complete:
```bash
INCOMPLETE=$(find "$PROJECT_DIR/tasks" -name "*.mdx" -exec grep -l "status: todo\|status: in-progress\|status: qa" {} \; | wc -l)
if [ "$INCOMPLETE" -eq 0 ]; then
  ${CLAUDE_PLUGIN_ROOT}/binaries/hypercraft project update "$PROJECT_SLUG" --status "qa"
fi
```"""

else:
  session: impl-captain
    prompt: """Verification failed. Status reverted to in-progress.

Report failures and suggest fixes."""

# ============================================================================
# Output Summary
# ============================================================================

output summary = session: impl-captain
  prompt: """Generate implementation summary.

## Implementation Summary

**Task**: {task_id}
**Result**: {PASS or FAIL}

### Verification
| Gate | Result |
|------|--------|
| Lint | {result} |
| Typecheck | {result} |
| Tests | {result} |
| Build | {result} |
| UI | {result} |

### Git
Working on current branch (use /hyper:implement-worktree for isolated branches)

### Next Steps
{If complete: next task}
{If failed: what to fix}
"""
  context: { task_spec, init }

# ============================================================================
# Phase 6: Compound Engineering (Optional)
# ============================================================================

agent compounding-agent:
  model: sonnet
  skills:
    - hypercraft               # Core framework
  env:
    HYPER_AGENT_ROLE: "worker"
    HYPER_AGENT_NAME: "compounding-agent"
    HYPER_WORKFLOW: "hyper-implement"
    HYPER_PHASE: "Compounding"
  prompt: """You extract and document learnings from implementation sessions.

Your responsibilities:
1. Analyze triggers detected during implementation
2. Focus on errors, corrections, and retry patterns
3. Extract actionable learnings for future implementations
4. Write to the project's learnings file

Prioritize learnings that help future implementations succeed faster."""

# Check for compound engineering triggers at workflow end
let triggers = **detect_compound_triggers(session)**

if triggers.length > 0:
  session: compounding-agent
    prompt: """Review the implementation workflow for compound engineering opportunities.

    **Task**: {task_id}
    **Triggers Detected**:
    {triggers}

    Evaluate each trigger:
    1. Was this a non-obvious issue that took investigation?
    2. Did we make multiple attempts before succeeding?
    3. Would this knowledge help future implementations?

    If worth documenting, write to:
    `$HYPER_WORKSPACE_ROOT/projects/{project_slug}/resources/learnings.md`

    Include:
    - What you were trying to accomplish
    - What went wrong and why
    - How it was fixed
    - How to prevent in the future

    If no triggers worth documenting, report: "No significant learnings to capture."

    Note: Query existing learnings first to avoid duplicates:
    ```bash
    grep -l "similar keywords" $HYPER_WORKSPACE_ROOT/projects/*/resources/learnings.md
    ```
    """
    context: { triggers, task_spec, init }
