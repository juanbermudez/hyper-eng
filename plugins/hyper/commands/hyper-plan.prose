# Hyper Planning Workflow
#
# Full planning workflow with 3 HITL gates:
#   Gate 1: Pre-research clarification
#   Gate 2: Post-research direction approval
#   Gate 3: Spec approval before task creation
#
# Usage: prose run hyper-plan.prose feature="Add user authentication"
#
# ARTIFACT PATTERN:
# - Prose bindings (.prose/runs/) = execution state, pointers to artifacts
# - Project artifacts (projects/) = actual deliverables via CLI
#
# PATH RESOLUTION:
# $HYPER_WORKSPACE_ROOT = ~/.hyper/accounts/{userId}/hyper/workspaces/{workspaceId}/
#
# STATUS FLOW:
# Project: planned → todo → in-progress → qa → completed
# Task: todo → in-progress → qa → complete

input feature: "Feature description to plan"
input depth: "Research depth: comprehensive (default) or deep"

# ============================================================================
# Agent Definitions
# ============================================================================

agent hyper-captain:
  model: opus
  persist: true
  prompt: """You are the Hyper Captain - the orchestrator for planning workflows.

Your role:
1. Coordinate research sub-agents
2. Synthesize findings into specifications
3. Present plans for human approval at gates
4. Create tasks from approved specs

Key principles:
- Specs matter more than code
- Always wait for human approval at HITL gates
- Write ARTIFACTS to $HYPER_WORKSPACE_ROOT/projects/ using the CLI
- Write BINDINGS as pointers/summaries to track execution state
- At approval gates: READ the artifact content and DISPLAY it to the user
- Update MDX frontmatter for status changes

ARTIFACT vs BINDING:
- ARTIFACT: The actual deliverable (project spec, task file, research doc)
  Location: $HYPER_WORKSPACE_ROOT/projects/{slug}/
  Created via: hyper CLI commands (project create, task create, file write)

- BINDING: Execution state tracking (summary + pointer to artifact)
  Location: $HYPER_WORKSPACE_ROOT/.prose/runs/{run-id}/bindings/
  Purpose: Enable workflow resume, track progress"""

agent researcher:
  model: sonnet
  prompt: """You are a research specialist. Gather comprehensive information about:
- Codebase patterns and conventions
- Best practices from official documentation
- Similar implementations in the project
- Potential challenges and edge cases

Return structured findings."""

# ============================================================================
# Phase 1: Initialize
# ============================================================================

let init = session "Initialize planning workflow"
  prompt: """Initialize the planning workflow.

1. Resolve workspace:
```bash
WORKSPACE_ROOT=$(${CLAUDE_PLUGIN_ROOT}/binaries/hyper workspace path)
export HYPER_WORKSPACE_ROOT="$WORKSPACE_ROOT"
echo "WORKSPACE_ROOT=$WORKSPACE_ROOT"
```

2. Generate run ID and project slug:
```bash
RUN_ID="plan-$(date +%Y%m%d-%H%M%S)-$(uuidgen | cut -c1-8)"
PROJECT_SLUG=$(echo "{feature}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
echo "RUN_ID=$RUN_ID"
echo "PROJECT_SLUG=$PROJECT_SLUG"
```

3. Create prose state directory:
```bash
mkdir -p "$HYPER_WORKSPACE_ROOT/.prose/runs/$RUN_ID/bindings"
mkdir -p "$HYPER_WORKSPACE_ROOT/.prose/agents/hyper-captain"
```

4. Create project directory structure:
```bash
mkdir -p "$HYPER_WORKSPACE_ROOT/projects/$PROJECT_SLUG/resources"
mkdir -p "$HYPER_WORKSPACE_ROOT/projects/$PROJECT_SLUG/tasks"
```

Report: WORKSPACE_ROOT, RUN_ID, PROJECT_SLUG

Artifact locations that will be created:
- Project spec: $HYPER_WORKSPACE_ROOT/projects/$PROJECT_SLUG/_project.mdx
- Research: $HYPER_WORKSPACE_ROOT/projects/$PROJECT_SLUG/resources/research-summary.md
- Tasks: $HYPER_WORKSPACE_ROOT/projects/$PROJECT_SLUG/tasks/task-NNN.mdx"""

# ============================================================================
# Phase 2: Pre-Research Clarification (HITL Gate 1)
# ============================================================================

let clarification = session: hyper-captain
  prompt: """HITL GATE 1: Pre-Research Clarification

Before spawning research agents, confirm understanding with the user.

**Feature Request**: {feature}

Use AskUserQuestion to clarify:

1. **Scope Confirmation**: Present your understanding of what "{feature}" means
   - What problem does this solve?
   - Who is the user/beneficiary?
   - What are the expected inputs/outputs?

2. **Boundary Questions**: Ask about scope limits
   - What is explicitly OUT of scope?
   - Are there related features we should NOT touch?
   - Any specific constraints (tech stack, patterns to follow)?

3. **Success Criteria**: What does "done" look like?
   - How will we verify this works?
   - Are there acceptance criteria already defined?

Wait for user response before proceeding to research.

After clarification, summarize:
- Confirmed understanding
- Scope boundaries
- Key constraints
- Success criteria"""
  context: { feature, init }

# ============================================================================
# Phase 3: Research
# ============================================================================

if **clarification complete**:
  let research = session: hyper-captain
    prompt: """Spawn research sub-agents in parallel.

Use the Task tool to spawn these agents:
1. repo-research-analyst - Analyze repository structure
2. best-practices-researcher - Gather external best practices
3. framework-docs-researcher - Get framework documentation
4. git-history-analyzer - Understand code evolution

Feature to research: {feature}
Clarified scope: {clarification}

After research completes, synthesize findings and WRITE TO ARTIFACT:

```bash
# Write research summary to artifact location
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file write \\
  "projects/$PROJECT_SLUG/resources/research-summary.md" \\
  --body "[synthesized research content]"
```

The binding for this session should contain:
- Summary of research findings
- Pointer to artifact: projects/{project_slug}/resources/research-summary.md
- List of key insights for next phase"""
    context: { feature, clarification, init }

# ============================================================================
# Phase 4: Direction Gate (HITL Gate 2)
# ============================================================================

let direction = session: hyper-captain
  prompt: """HITL GATE 2: Post-Research Direction Approval

**IMPORTANT**: Read and display the actual research artifact to the user.

1. Read the research artifact:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file read \\
  "projects/$PROJECT_SLUG/resources/research-summary.md" \\
  --json
```

2. Present to user with AskUserQuestion:

## Direction Check

**Feature**: {feature}

### Research Findings
[Display the FULL content from the research artifact - do NOT summarize]

### Proposed Approach
Based on research, outline:
- High-level architecture/approach
- Key components to create/modify
- Integration points

### Key Decisions Needed
1. [Decision point 1 - present options]
2. [Decision point 2 - present options]

### Potential Risks
- [Risk 1 and mitigation]
- [Risk 2 and mitigation]

---

**GATE: Direction Approval Required**

Ask user:
- Approve this direction?
- Any adjustments needed?
- Additional constraints to consider?

Wait for explicit approval before proceeding."""
  context: { feature, research, clarification, init }

# ============================================================================
# Phase 5: Detailed Specification
# ============================================================================

if **direction approved**:
  let spec = session: hyper-captain
    prompt: """Create detailed specification and write to artifact.

1. Create project via CLI:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper project create \\
  --slug "$PROJECT_SLUG" \\
  --title "{feature}" \\
  --priority "high" \\
  --summary "[one-line summary from research]" \\
  --json
```

2. Write FULL specification to _project.mdx:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file write \\
  "projects/$PROJECT_SLUG/_project.mdx" \\
  --body "[full specification content]"
```

The specification MUST include:
- ## Overview - Problem statement and solution
- ## Goals - Numbered list of objectives
- ## Technical Approach - Architecture, components, patterns
- ## Implementation Phases - Numbered phases for task breakdown
- ## Acceptance Criteria - Testable success conditions
- ## Out of Scope - Explicit exclusions

The binding for this session should contain:
- Summary of spec created
- Pointer to artifact: projects/{project_slug}/_project.mdx
- List of implementation phases for task creation"""
    context: { feature, research, direction, clarification, init }

# ============================================================================
# Phase 6: Spec Approval Gate (HITL Gate 3)
# ============================================================================

let spec_approval = session: hyper-captain
  prompt: """HITL GATE 3: Specification Approval

**IMPORTANT**: Read and display the actual spec artifact to the user.

1. Read the project spec:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file read \\
  "projects/$PROJECT_SLUG/_project.mdx" \\
  --json
```

2. Present FULL specification to user:

## Specification Review

**Project**: {feature}
**Location**: $HYPER_WORKSPACE_ROOT/projects/{project_slug}/_project.mdx

### Full Specification
[Display the ENTIRE content from _project.mdx - do NOT summarize]

---

**GATE: Specification Approval Required**

Ask user:
- Approve this specification?
- Any sections need revision?
- Ready to create tasks?

Wait for explicit approval before creating tasks."""
  context: { spec, init }

# ============================================================================
# Phase 7: Task Breakdown
# ============================================================================

if **spec approved**:
  let tasks = session: hyper-captain
    prompt: """Create tasks from approved specification.

1. Read the spec to extract implementation phases:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file read \\
  "projects/$PROJECT_SLUG/_project.mdx" \\
  --json
```

2. For EACH phase in the spec, create a task:
```bash
# Create task via CLI (generates ID automatically)
TASK_RESULT=$(${CLAUDE_PLUGIN_ROOT}/binaries/hyper task create \\
  --project "$PROJECT_SLUG" \\
  --title "Phase N: [Phase Title]" \\
  --priority "high" \\
  --json)

# Extract task ID from result
TASK_ID=$(echo "$TASK_RESULT" | jq -r '.id')
TASK_FILE=$(echo "$TASK_RESULT" | jq -r '.file')
```

3. Write FULL task content to each task file:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper file write \\
  "$TASK_FILE" \\
  --body "[full task specification]"
```

Each task body MUST include:
- ## Objective - What this task accomplishes
- ## Implementation Steps - Numbered steps to complete
- ## Acceptance Criteria - How to verify completion
- ## Dependencies - Other tasks this depends on (if any)

4. Update project status to 'todo':
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper project update "$PROJECT_SLUG" --status "todo"
```

The binding for this session should contain:
- List of tasks created with IDs
- Pointer to each task file
- Summary of task breakdown"""
    context: { spec, init }

# ============================================================================
# Output Summary
# ============================================================================

output summary = session: hyper-captain
  prompt: """Generate planning summary.

Read the final project state:
```bash
${CLAUDE_PLUGIN_ROOT}/binaries/hyper project get "$PROJECT_SLUG" --json
${CLAUDE_PLUGIN_ROOT}/binaries/hyper task list --project "$PROJECT_SLUG" --json
```

## Planning Complete

**Project**: {feature}
**Slug**: {project_slug}
**Status**: todo

### Artifacts Created

| Artifact | Location |
|----------|----------|
| Project Spec | `$HYPER_WORKSPACE_ROOT/projects/{project_slug}/_project.mdx` |
| Research Summary | `$HYPER_WORKSPACE_ROOT/projects/{project_slug}/resources/research-summary.md` |
| Tasks | `$HYPER_WORKSPACE_ROOT/projects/{project_slug}/tasks/task-NNN.mdx` |

### Tasks Created
[List all tasks with IDs and titles from CLI output]

### Next Steps
1. Run `/hyper:implement {project_slug}` to start implementation
2. Or implement individual tasks: `/hyper:implement {project_slug}/{task_id}`

### Prose State (for workflow resume)
`$HYPER_WORKSPACE_ROOT/.prose/runs/{run_id}/`
"""
  context: { feature, init, spec, tasks }
